{"componentChunkName":"component---src-templates-docs-js","path":"/computer-technology/builder-pattern-java","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Gitbook Boilerplate | Hasura","docsLocation":"https://github.com/bodhi-root/public-wiki/tree/master/content"}},"mdx":{"fields":{"id":"d2a75484-9952-51fe-a790-6884039c037d","title":"The Builder Pattern in Java","slug":"/computer-technology/builder-pattern-java"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"The Builder Pattern in Java\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Summary\"), mdx(\"p\", null, \"If you find yourself writing several variations of a constructor or function to make them easier to invoke, or if you find yourself instantiating a class and then calling 5 or more \\\"setXXX()\\\" functions to configure it... the builder pattern might be for you.  The builder pattern lets you create objects with syntax like:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"DataTable table = new TableReader.Builder()\\n    .file(\\\"myfile.txt\\\")\\n    .sep(\\\"|\\\")\\n    .header(false)\\n    .columnNames(\\\"store_id\\\", \\\"division_number\\\", \\\"store_number\\\").build().readTable();\\n\")), mdx(\"p\", null, \"This is an alternative to putting all those parameters into a single function/constructor of invoking a bunch of setters one-at-a-time.  The builder pattern is used in Apache Avro and other places where convenience on the user's end amid complicated (and frequently optional) parameters is important.  It also allows you to create your data classes as Immutable objects with all properties set in the constructor.  There seems to be a preference amid developers lately for this type of immutability in some of their objects.\"), mdx(\"h2\", null, \"Motivation\"), mdx(\"p\", null, \"Have you ever been jealous of Python or R programmers who get to write code like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"data <- read.table(file=\\\"myfile.txt\\\", sep=\\\"|\\\", header=FALSE, col.names=c(\\\"store_id\\\",\\\"division_number\\\", \\\"store_number\\\"))\\n\")), mdx(\"p\", null, \"The definition of this R function defines 25 parameters:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"read.table(file, header = FALSE, sep = \\\"\\\", quote = \\\"\\\\\\\"'\\\",\\n           dec = \\\".\\\", numerals = c(\\\"allow.loss\\\", \\\"warn.loss\\\", \\\"no.loss\\\"),\\n           row.names, col.names, as.is = !stringsAsFactors,\\n           na.strings = \\\"NA\\\", colClasses = NA, nrows = -1,\\n           skip = 0, check.names = TRUE, fill = !blank.lines.skip,\\n           strip.white = FALSE, blank.lines.skip = TRUE,\\n           comment.char = \\\"#\\\",\\n           allowEscapes = FALSE, flush = FALSE,\\n           stringsAsFactors = default.stringsAsFactors(),\\n           fileEncoding = \\\"\\\", encoding = \\\"unknown\\\", text, skipNul = FALSE)\\n\")), mdx(\"p\", null, \"Typically, only 3 or 4 of these are used at any given time.  But sometimes you will need to use one of the less common options.\"), mdx(\"p\", null, \"As a Java programmer, it's easy to get a bit envious of the resulting simplicity (at least on the invoking side) for these types of languages.  We would never want to define a Java function with 25 parameters.  Keeping track of which one was which (without having the \\\"name = \\\" convention) would be insanity.  This is where the builder pattern really shines.  The builder pattern would allow us to use something like the following to perform this same task:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"DataTable table = new TableReader.Builder()\\n    .file(\\\"myfile.txt\\\")\\n    .sep(\\\"|\\\")\\n    .header(false)\\n    .columnNames(\\\"store_id\\\", \\\"division_number\\\", \\\"store_number\\\").build().readTable();\\n\")), mdx(\"p\", null, \"Sure it's still a little verbose... but it's better than:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"TableReader reader = new TableReader();\\nreader.setFile(\\\"myfile.txt\\\");\\nreader.setSep(\\\"|\\\");\\nreader.setHeader(false);\\nreader.setColumnNames(\\\"store_id\\\", \\\"division_number\\\", \\\"store_number\\\");\\nDataTable table = reader.readTable();\\n\")), mdx(\"p\", null, \"and it's way better than:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"DataTable table = new TableReader(\\n    \\\"myfile.txt\\\", \\\"|\\\", null, null, false,\\n     new String [] {\\\"store_id\\\", \\\"division_number\\\", \\\"store_number\\\"}).readTable();\\n\")), mdx(\"p\", null, \"NOTE: The 'nulls' indicate that we'd likely have to define 10 or so variations of this files with different parameter signatures, and we still might not have one that fits our needs exactly. So we'd find the closest one and omit unneeded parameters.\"), mdx(\"h2\", null, \"Implementation\"), mdx(\"p\", null, \"This article provides a great overview of how to use the builder pattern in Java.  The code patterns they use are shown below:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"public class User {\\n\\n  private final String firstName; // required\\n  private final String lastName;  // required\\n  private final int age;          // optional\\n  private final String phone;     // optional\\n  private final String address;   // optional\\n\\n  private User(Builder builder) {\\n    this.firstName = builder.firstName;\\n    this.lastName  = builder.lastName;\\n    this.age       = builder.age;\\n    this.phone     = builder.phone;\\n    this.address   = builder.address;\\n  }\\n\\n  public String getFirstName() {\\n    return firstName;\\n  }\\n\\n  public String getLastName() {\\n    return lastName;\\n  }\\n\\n  public int getAge() {\\n    return age;\\n  }\\n\\n  public String getPhone() {\\n    return phone;\\n  }\\n\\n  public String getAddress() {\\n    return address;\\n  }\\n\\n  public static class Builder {\\n\\n    private final String firstName;\\n    private final String lastName;\\n    private int age;\\n    private String phone;\\n    private String address;\\n\\n    public Builder(String firstName, String lastName) {\\n      this.firstName = firstName;\\n      this.lastName = lastName;\\n    }\\n\\n    public Builder age(int age) {\\n      this.age = age;\\n      return this;\\n    }\\n\\n    public Builder phone(String phone) {\\n      this.phone = phone;\\n      return this;\\n    }\\n\\n    public Builder address(String address) {\\n      this.address = address;\\n      return this;\\n    }\\n\\n    public User build() {\\n      return new User(this);\\n    }\\n\\n  }\\n}\\n\")), mdx(\"p\", null, \"The object can then be created with:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"public User getUser() {\\n  return new\\n    User.Builder(\\\"Jhon\\\", \\\"Doe\\\")\\n    .age(30)\\n    .phone(\\\"1234567\\\")\\n    .address(\\\"Fake address 1234\\\")\\n    .build();\\n}\\n\")), mdx(\"p\", null, \"Note that in the example above they've gone as far as to create a private constructor so that the builder is the only way to create this option.  That might be a step too far... especially if you have something that you want to work as a configurable bean that Spring or Guice might create for you.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://avro.apache.org/docs/1.8.1/gettingstartedjava.html\"\n  }), \"Apache Avro\"), \" uses a similar syntax, except that instead of using \\\"new User.Builder()\\\" they would use \\\"User.newBuilder()\\\".  It's just a matter of preference at that point.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#summary","title":"Summary"},{"url":"#motivation","title":"Motivation"},{"url":"#implementation","title":"Implementation"}]},"parent":{"relativePath":"computer-technology/builder-pattern-java.md"},"frontmatter":{"metaTitle":null,"metaDescription":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/computer-technology","title":"Computer Technology"}}},{"node":{"fields":{"slug":"/","title":"Dan's Notes"}}},{"node":{"fields":{"slug":"/personal","title":"About Me"}}},{"node":{"fields":{"slug":"/computer-technology/builder-pattern-java","title":"The Builder Pattern in Java"}}},{"node":{"fields":{"slug":"/computer-technology/databases","title":"Databases"}}},{"node":{"fields":{"slug":"/computer-technology/docker-and-containers","title":"Docker and Containers"}}},{"node":{"fields":{"slug":"/computer-technology/docker","title":"Docker"}}},{"node":{"fields":{"slug":"/computer-technology/git","title":"Git"}}},{"node":{"fields":{"slug":"/computer-technology/gpl-beer-clause-license","title":"GPL License with Modified \"Beer Clause\""}}},{"node":{"fields":{"slug":"/computer-technology/html-css","title":"HTML and CSS"}}},{"node":{"fields":{"slug":"/computer-technology/proxy-firewall","title":"Proxy Firewalls"}}},{"node":{"fields":{"slug":"/computer-technology/r-and-docker","title":"R and Docker"}}},{"node":{"fields":{"slug":"/computer-technology/react","title":"React Notes"}}},{"node":{"fields":{"slug":"/computer-technology/regular-expressions","title":"Regular Expression Cheat Sheet"}}},{"node":{"fields":{"slug":"/computer-technology/tao-of-programming","title":"The Tao of Programming"}}},{"node":{"fields":{"slug":"/personal/quotes","title":"Quotes"}}},{"node":{"fields":{"slug":"/personal/reading-list","title":"Reading List"}}},{"node":{"fields":{"slug":"/personal/work_rules","title":"Work Rules! (Notes)"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"d2a75484-9952-51fe-a790-6884039c037d"}}}